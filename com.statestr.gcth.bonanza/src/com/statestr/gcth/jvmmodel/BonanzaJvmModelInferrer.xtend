/*
 * generated by Xtext 2.16.0
 */
package com.statestr.gcth.jvmmodel

import com.google.inject.Inject
import com.statestr.gcth.bonanza.AbstractModel
import com.statestr.gcth.bonanza.Entity
import com.statestr.gcth.bonanza.Mapper
import com.statestr.gcth.bonanza.MapperField
import com.statestr.gcth.bonanza.Model
import com.statestr.gcth.bonanza.Source
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import java.math.BigDecimal

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class BonanzaJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
//		model.models.filter(Transform).inferForTransforms(model.name, acceptor, isPreIndexingPhase)
		for (e : model.models) {
			e.infer(model.name, acceptor, isPreIndexingPhase)
		}

	}

	def dispatch void infer(AbstractModel model, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		switch model {
			case model instanceof Source: model.infer(packageName, acceptor, isPreIndexingPhase)
			case model instanceof Entity: model.infer(packageName, acceptor, isPreIndexingPhase)
			case model instanceof Mapper: model.infer(packageName, acceptor, isPreIndexingPhase)
		}
	}

	def dispatch void infer(Mapper mapper, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
		// An implementation for the initial hello world example could look like this:
		acceptor.accept(mapper.toClass(packageName + "." + mapper.name)) [
			val source = mapper.source
			val target = mapper.entity
			members += source.toField(source.name, typeRef(source.fullyQualifiedName.toString))
			members += source.toConstructor [
				parameters += source.toParameter(source.name, typeRef(source.fullyQualifiedName.toString))
				body = '''
					this.«source.name» = «source.name»;
				'''
			]

			members += source.toMethod("get" + target.name, typeRef(target.fullyQualifiedName.toString)) [
				body = '''
					«typeRef(target.fullyQualifiedName.toString)» «target.name.toFirstLower» = new «typeRef(target.fullyQualifiedName.toString)»();
					
					«FOR f : mapper.fields»
						«compile(f, source, target)»
					«ENDFOR»
					return «target.name.toFirstLower»;
				'''
			]
		]
	}
	
	def compile(XExpression express){
		
	}

	def compile(MapperField field, Source source, Entity target) {
		val from = field.from
		val to = field.to
		val call = field.call
		if (call !== null) {
			'''
				«target.name.toFirstLower».set«to.name.toFirstUpper»(«call.compile»);
			'''
		} else {

			if (from.hardCode !== null) {
				'''
					«target.name.toFirstLower».set«to.name.toFirstUpper»(«from.hardCode»);
				'''
			} else {
				if (from.type !== null) {

					return switch to.type.simpleName {
						case BigDecimal.simpleName: '''
							«target.name.toFirstLower».set«to.name.toFirstUpper»(new java.math.BigDecimal(this.«source.name».get«from.type.name»()));
						'''
						default: '''
							«target.name.toFirstLower».set«to.name.toFirstUpper»(this.«source.name».get«from.type.name»());
						'''
					}

				}
			}

		}
	}

	def dispatch void infer(Source source, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
		// An implementation for the initial hello world example could look like this:
		acceptor.accept(source.toClass(packageName + "." + source.name)) [
			for (field : source.fields) {

				var type = typeRef(String)
				if (field.type !== null) {
					type = typeRef(field.type.fullyQualifiedName.toString)
				}
				members += field.toField(field.name, type)
				members += field.toSetter(field.name, type)
				members += field.toGetter(field.name, type)
			}
		]
	}

	def dispatch void infer(Entity entity, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
		// An implementation for the initial hello world example could look like this:
		acceptor.accept(entity.toClass(packageName + "." + entity.name)) [
			for (field : entity.fields) {

				members += field.toField(field.name, field.type)
				members += field.toSetter(field.name, field.type)
				members += field.toGetter(field.name, field.type)
			}
		]
	}

}
