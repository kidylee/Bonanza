/*
 * generated by Xtext 2.16.0
 */
package com.statestr.gcth.jvmmodel

import com.google.inject.Inject
import com.statestr.gcth.bonanza.AbstractModel
import com.statestr.gcth.bonanza.Entity
import com.statestr.gcth.bonanza.Mapper
import com.statestr.gcth.bonanza.MapperField
import com.statestr.gcth.bonanza.Model
import com.statestr.gcth.bonanza.Source
import com.statestr.gcth.bonanza.TransformCall
import com.statestr.gcth.bonanza.UtilClass
import java.math.BigDecimal
import java.util.List
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class BonanzaJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	val gcRef = GoldCopyReference.instance

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
//		model.models.filter(Transform).inferForTransforms(model.name, acceptor, isPreIndexingPhase)
		for (e : model.models) {
			e.infer(model.name, acceptor, isPreIndexingPhase)
		}

	}

	def dispatch void infer(AbstractModel model, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		switch model {
			case model instanceof Source: model.infer(packageName, acceptor, isPreIndexingPhase)
			case model instanceof Entity: model.infer(packageName, acceptor, isPreIndexingPhase)
			case model instanceof Mapper: model.infer(packageName, acceptor, isPreIndexingPhase)
			case model instanceof UtilClass: model.infer(packageName, acceptor, isPreIndexingPhase)
		}
	}

	def dispatch void infer(UtilClass util, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		acceptor.accept(util.toClass(packageName + "." + util.name)) [
			for (t : util.transforms) {
				members += t.toMethod(t.name, t.type) [
					for (param : t.params) {
						static = true

						parameters += param.toParameter(param.name, param.parameterType)

					}
					body = t.body
				]
			}
		]
	}

	def dispatch void infer(Mapper mapper, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
		// An implementation for the initial hello world example could look like this:
		acceptor.accept(mapper.toClass(packageName + "." + mapper.name)) [
			val source = mapper.source
			val target = mapper.entity
			members += source.toField(source.name, typeRef(source.fullyQualifiedName.toString))
			members += source.toConstructor [
				parameters += source.toParameter(source.name, typeRef(source.fullyQualifiedName.toString))
				body = '''
					this.«source.name» = «source.name»; 
				'''
			]
			if (target.name !== null) {
				members += source.toMethod("get" + target.name, typeRef(target.fullyQualifiedName.toString)) [
					body = '''
						«typeRef(target.fullyQualifiedName.toString)» «target.name.toFirstLower» = new «typeRef(target.fullyQualifiedName.toString)»();
						
						«FOR f : mapper.fields»
							«compile(f, source, target)»
						«ENDFOR»
						return «target.name.toFirstLower»;
					'''
				]
			}

		]
	}

	def compile(TransformCall call, Source source, Entity target) {
		'''«call.utilClass.name».«call.transform.name»(«generateParameters(call, source)»)'''

	}

	protected def generateParameters(TransformCall call, Source source) '''
		«FOR param : call.params SEPARATOR ','»
			«IF param.field !== null»
				this.«source.name».get«param.field.name.toFirstUpper»()
			«ELSE»
				«param.const»
			«ENDIF»
		«ENDFOR»
	'''

	def compile(MapperField field, Source source, Entity target) {
		val from = field.from
		val to = field.to
		val call = field.call

		if (call !== null) {
			'''
				«target.name.toFirstLower».set«to.name.toFirstUpper»(«call.compile(source, target)»);
			'''
		} else {

			if (from.hardCode !== null) {
				'''
					«target.name.toFirstLower».set«to.name.toFirstUpper»(«from.hardCode»);
				'''
			} else {
				if (from.type !== null) {

					return switch to.type.simpleName {
						case BigDecimal.simpleName: '''
							«target.name.toFirstLower».set«to.name.toFirstUpper»(new java.math.BigDecimal(this.«source.name».get«from.type.name»()));
						'''
						default: '''
							«target.name.toFirstLower».set«to.name.toFirstUpper»(this.«source.name».get«from.type.name»());
						'''
					}

				}
			}

		}
	}

	def boolean hasSubSource(Source source) {

		return source.subsources.size != 0
	}

	def List<Source> subsources(Source source) {
		var sub = newArrayList
		for (f : source.fields) {
			if (f.type !== null) {
				sub.add(f.type)
			}
		}
		return sub
	}

	def compileSource(Source source) '''
		«IF source.sourceID != 0 »
			«source.name» «source.name.toFirstLower» = new «source.name»(ucTxn.getRawTransaction());
		«ENDIF»
		
		«IF source.mapper !== null»
			«source.compileSourceWithMapper»
		«ENDIF»
			
		«IF source.hasSubSource »
			«FOR s: source.subsources»
				«s.name» «s.name.toFirstLower» = «source.name.toFirstLower».get«s.name»();
				«s.compileSource»
			«ENDFOR»
			
			
		«ENDIF»
			
	'''

	def compileSourceWithMapper(Source source) '''
		«val mapper = source.mapper»
		«mapper.name» «mapper.name.toFirstLower» = new «mapper.name»(«source.name.toFirstLower»);
		«(mapper.entity.fullyQualifiedName.toString + "DAO")» «mapper.entity.name.toFirstLower»DAO = sharedService.getService(«(mapper.entity.fullyQualifiedName.toString + "DAO")».class);
«««		todo save failed logic
		«mapper.entity.name.toFirstLower»DAO.save(«mapper.name.toFirstLower».get«mapper.entity.name»());
	'''

	def dispatch void infer(Source source, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {

		if (source.sourceID != 0) {
			acceptor.accept(source.toClass(packageName + "." + source.name + "Processor")) [

				superTypes += typeRef(gcRef.abstractComponent)
				superTypes += typeRef(gcRef.workflowProcessor)
				members += source.toMethod("process", typeRef(Void.TYPE)) [
					annotations += annotationRef(Override)
					annotations += annotationRef(gcRef.proxyMetrics)
					parameters += source.toParameter("ucTxn", typeRef(gcRef.useCaseTxn))
					parameters += source.toParameter("processResource", typeRef(gcRef.processResource))
					parameters += source.toParameter("workflowSession", typeRef(gcRef.workflowSession))
					parameters += source.toParameter("sharedService", typeRef(gcRef.sharedServices))
					parameters += source.toParameter("workflowControl", typeRef(gcRef.workflowControl))
					body = '''«source.compileSource»'''
				]

			]
		}

		acceptor.accept(source.toClass(packageName + "." + source.name)) [

			members += source.toField("raw", typeRef(gcRef.rawTransaction))
			members += source.toConstructor [
				parameters += source.toParameter("rawTransaction", typeRef(gcRef.rawTransaction))
				body = '''this.raw = rawTransaction;'''
			]

			for (field : source.fields) {

				members += field.toField(field.name, typeRef(String))
				members += field.toSetter(field.name, typeRef(String))
				members += field.toGetter(field.name, typeRef(String))
				if (field.type !== null) {
					val type = typeRef(field.type.fullyQualifiedName.toString)
					members += field.toField(field.type.name.toFirstLower, type)
					members += field.toMethod("get" + field.type.name.toFirstUpper, type) [
						body = '''return this.«field.type.name.toFirstLower»;'''
					]
				}

			}

		]

	}

	def dispatch void infer(Entity entity, String packageName, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
		// An implementation for the initial hello world example could look like this:
		acceptor.accept(entity.toClass(packageName + "." + entity.name)) [
			for (field : entity.fields) {

				members += field.toField(field.name, field.type)
				members += field.toSetter(field.name, field.type)
				members += field.toGetter(field.name, field.type)
			}
		]

		acceptor.accept(entity.toInterface(packageName + "." + entity.name + "DAO") [

			members += entity.toMethod("save", typeRef(int)) [
				abstract = true
				parameters += entity.toParameter(entity.name.toFirstLower, typeRef(entity.fullyQualifiedName.toString))

			]

		])
	}

}
