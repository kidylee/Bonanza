/*
 * generated by Xtext 2.16.0
 */
package com.statestr.gcth.formatting2

import com.google.common.base.Strings
import com.google.inject.Inject
import com.statestr.gcth.bonanza.BonanzaPackage
import com.statestr.gcth.bonanza.Entity
import com.statestr.gcth.bonanza.EntityField
import com.statestr.gcth.bonanza.FromExpress
import com.statestr.gcth.bonanza.Mapper
import com.statestr.gcth.bonanza.MapperField
import com.statestr.gcth.bonanza.Model
import com.statestr.gcth.bonanza.Source
import com.statestr.gcth.bonanza.SourceField
import com.statestr.gcth.bonanza.Transform
import com.statestr.gcth.bonanza.UtilClass
import com.statestr.gcth.services.BonanzaGrammarAccess
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.xbase.formatting2.XbaseFormatter

import static extension org.eclipse.xtext.nodemodel.util.NodeModelUtils.*

class BonanzaFormatter extends XbaseFormatter {

	@Inject extension BonanzaGrammarAccess

	def dispatch void format(Model model, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (xImportSection : model.imports) {
			xImportSection.format
		}

		val lastEntity = model.models.last
		for (abstractModel : model.models) {
			abstractModel.format

			if (abstractModel === lastEntity)
				abstractModel.append[newLines = 1]
			else
				abstractModel.append[newLines = 2]

		}

	}

	def dispatch void format(UtilClass util, extension IFormattableDocument document) {
		val open = util.regionFor.keyword(utilClassAccess.leftCurlyBracketKeyword_2)
		val close = util.regionFor.keyword("}")
		open.append[newLine]
		interior(open, close)[indent]
		val last = util.transforms.last
		for (transform : util.transforms) {
			transform.format

			if (transform === last)
				transform.append[newLines = 1]
			else
				transform.append[newLines = 2]
		}
	}

	def dispatch void format(Transform tran, extension IFormattableDocument document) {
		val open = tran.regionFor.keyword(transformAccess.leftParenthesisKeyword_2)
		val close = tran.regionFor.keyword("}")
//		open.append[newLine]
		interior(open, close)[indent]

		tran.body.format
	}

	def dispatch void format(Entity entity, extension IFormattableDocument document) {
		val open = entity.regionFor.keyword(entityAccess.leftCurlyBracketKeyword_2)
		val close = entity.regionFor.keyword("}")
		open.append[newLine]
		interior(open, close)[indent]
		val maxLengthOfFieldName = entity.getMaxEntityFieldNameLength
		for (entityField : entity.fields) {
			entityField.format(document, maxLengthOfFieldName)
			entityField.prepend[space = "    "]
			entityField.append[newLines = 1]
		}
	}

	def void format(EntityField entityField, extension IFormattableDocument document, int maxlength) {
		val nameLength = entityField.name.length
		entityField.regionFor.feature(BonanzaPackage.Literals.ENTITY_FIELD__NAME).append [
			space = Strings.repeat(" ", maxlength - nameLength + 4)
		]

	}

	def getMaxEntityFieldNameLength(Entity entity) {

		var max = 0
		for (field : entity.fields) {
			var name = field.name
			max = Math.max(name.length, max)
		}

		return max

	}

	def dispatch void format(Source source, extension IFormattableDocument document) {
		val open = source.regionFor.keyword(sourceAccess.leftCurlyBracketKeyword_9)
		val close = source.regionFor.keyword("}")
		open.append[newLine]
		interior(open, close)[indent]

		val maxLengthOfFieldName = source.getMaxSourceFieldNameLength

		for (sourceField : source.fields) {
			sourceField.format(document, maxLengthOfFieldName)

			sourceField.prepend[space = "    "]
			sourceField.append[newLines = 1]
		}
	}

	private def getMaxSourceFieldNameLength(Source source) {

		var max = 0
		for (field : source.fields) {
			var name = field.name
			var type = field.type?.name ?: ""
			max = Math.max(name.length + type.length, max)
		}

		return max

	}

	private def void format(SourceField sourceField, extension IFormattableDocument document, int maxlength) {
		val nameLength = sourceField.name.length
		val type = sourceField.type?.name ?: ""

		if (type !== "") {
			sourceField.regionFor.feature(BonanzaPackage.Literals.SOURCE_FIELD__NAME).append [
				space = " "
			]

		}

		sourceField.regionFor.feature(BonanzaPackage.Literals.SOURCE_FIELD__PATH).prepend [
			if (type !== "") {
				space = Strings.repeat(" ", maxlength - nameLength - type.length + 1)
			} else {
				space = Strings.repeat(" ", maxlength - nameLength - type.length + 3)
			}

		]
	}

	private def maxLengthOfFromName(Mapper mapping) {

		var max = 0
		for (field : mapping.fields) {
			var text = field.from.findActualNodeFor.tokenText
			max = Math.max(max, text.length)
		}

		return max
	}

	private def maxLengthOfToName(Mapper mapping) {

		var max = 0
		for (field : mapping.fields) {
			var text = field.to.findActualNodeFor.tokenText
			max = Math.max(max, text.length)
		}

		return max
	}

	def dispatch void format(Mapper mapping, extension IFormattableDocument document) {
		val open = mapping.regionFor.keyword(mapperAccess.leftCurlyBracketKeyword_11)
		val close = mapping.regionFor.keyword("}")
		open.append[newLine]
		interior(open, close)[indent]

		val maxLengthOfSourceFieldName = mapping.maxLengthOfFromName
		val maxLengthOfEntityFieldName = mapping.maxLengthOfToName

		for (field : mapping.fields) {
			field.format(document, maxLengthOfSourceFieldName, maxLengthOfEntityFieldName)

			field.prepend[space = "    "]
			field.append[newLines = 1]
		}
	}

	def void format(MapperField field, extension IFormattableDocument document, int maxlengthOfFrom,
		int maxLengthOfTo) {

		field.from.format(document, maxlengthOfFrom)
		field.regionFor.keyword('with').prepend [
			space = Strings.repeat(" ", maxLengthOfTo - field.to.findActualNodeFor.tokenText.length + 1)
		]
		field.regionFor.keyword('=>').append[space = " "]
	}

	def void format(FromExpress from, extension IFormattableDocument document, int maxlength) {
		val fromExpress = from?.findActualNodeFor?.tokenText ?: ""

		from.append[space = Strings.repeat(" ", maxlength - fromExpress.length + 1)]
	}

}
